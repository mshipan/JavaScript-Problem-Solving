// Sliding window হল একটি কৌশল যেখানে একটি "উইন্ডো" নির্দিষ্ট আকারে একটি অ্যারে বা স্ট্রিংয়ের উপর স্লাইড করে।
// এটি একাধিক সমস্যার সমাধানে ব্যবহার করা হয় যেখানে সিকোয়েন্সের ধারাবাহিক উপাদানগুলির উপর কিছু নির্দিষ্ট
// কাজ করতে হয়। এই কৌশলটি বেশিরভাগ সময় contiguous subarrays বা substrings সম্পর্কিত সমস্যার সমাধানে ব্যবহৃত হয়।

// --------------------------------------------------------------------------

// কিভাবে কাজ করে:

// 1. প্রথমে উইন্ডোটি একটি নির্দিষ্ট আকারে তৈরি করা হয় (যেমন, নির্দিষ্ট সংখ্যক উপাদান)।
// 2. এরপর সেই উইন্ডোটি এক এক করে অ্যারে বা স্ট্রিংয়ের উপর স্লাইড করা হয়।
// 3. উইন্ডোর মধ্যে কোনো শর্ত পূর্ণ হলে, সে অনুযায়ী ফলাফল বা গণনা করা হয়।

// --------------------------------------------------------------------------

// উদাহরণ: ধরা যাক, আমাদের একটি অ্যারে আছে এবং আমাদের জানতে হবে যে, নির্দিষ্ট আকারের সাবঅ্যারেগুলির মধ্যে সর্বোচ্চ যোগফল কত।
function maxSumSubarray(arr, k) {
  let maxSum = 0;
  let currentSum = 0;

  // Calculate the sum of the first window of size 'k'
  for (let i = 0; i < k; i++) {
    currentSum += arr[i];
  }

  maxSum = currentSum;

  // Slide the window and update the sum
  for (let i = k; i < arr.length; i++) {
    currentSum += arr[i] - arr[i - k]; // add the new element and remove the element going out of the window
    maxSum = Math.max(maxSum, currentSum);
  }

  return maxSum;
}

const arr = [2, 1, 5, 1, 3, 2];
const k = 3;
console.log(maxSumSubarray(arr, k)); // Output: 9

// এখানে:

// - প্রথমে, আমরা প্রথম উইন্ডো (যার আকার k) এর যোগফল বের করছি।
// - তারপর, আমরা স্লাইডিং উইন্ডো ব্যবহার করে পরবর্তী উপাদানগুলির যোগফল আপডেট করছি এবং সর্বোচ্চ যোগফল বের করছি।

// --------------------------------------------------------------------------

// Time complexity: O(n) Space complexity: O(1)
