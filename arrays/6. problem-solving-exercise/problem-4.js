// Write a function that creates a new array by removing all negative numbers from an array.

// Approach 1: Using for Loop
function removeNegativeNums(arr) {
  let newArr = []; // পজিটিভ সংখ্যাগুলো সংরক্ষণ করার জন্য একটি অ্যারে
  for (let i = 0; i <= arr.length - 1; i++) {
    if (arr[i] >= 0) {
      // যদি উপাদানটি নেগেটিভ না হয়
      newArr.push(arr[i]); // পজিটিভ সংখ্যা অ্যারেতে যোগ করুন
    }
  }
  return newArr;
}

const array = [-4, -3, -2, 0, 1, 2, 3];

console.log(removeNegativeNums(array));

// ---------------------------------------------------------------------------

// ব্যাখ্যা:

// 1. একটি নতুন অ্যারে newArr তৈরি করা হয়েছে।
// 2. প্রতিটি উপাদান চেক করা হচ্ছে, যদি উপাদানটি নেগেটিভ না হয় (>= 0), তাহলে সেটি নতুন অ্যারেতে যোগ করা হচ্ছে।
// 3. শেষে newArr অ্যারেটি রিটার্ন করা হচ্ছে।

// ---------------------------------------------------------------------------

// Approach 2: Using filter() Method
function removeNegativeNumbers(arr) {
  return arr.filter((num) => num >= 0);
}

const nums = [-10, 20, -30, -50, 0, 10, 16];
console.log(removeNegativeNumbers(nums));

// ---------------------------------------------------------------------------

// ব্যাখ্যা:

// 1. filter() মেথড একটি ক্যালব্যাক ফাংশন ব্যবহার করে।
// 2. প্রতিটি উপাদান চেক করা হয়। যদি উপাদানটি >= 0 হয়, তাহলে সেটি নতুন অ্যারেতে যোগ করা হয়।
// 3. অবশেষে নতুন অ্যারে রিটার্ন করা হয়।

// ---------------------------------------------------------------------------

// Edge Case: Empty Array
// - যদি ইনপুট অ্যারে ফাঁকা হয়, উভয় পদ্ধতিই ফাঁকা অ্যারে [] রিটার্ন করবে কারণ চেক করার মতো কোনো উপাদান নেই।

// ---------------------------------------------------------------------------

// Time Complexity:
// for লুপ:
// - O(n), কারণ প্রতিটি উপাদান একবার চেক করা হয়।
// filter():
// - O(n), কারণ এটি একইভাবে প্রতিটি উপাদান চেক করে।

// ---------------------------------------------------------------------------

// Space Complexity:
// - উভয় পদ্ধতিতে নতুন অ্যারে তৈরি করতে অতিরিক্ত স্পেস ব্যবহার করা হয়, যা O(n)।
