// Given a sorted array, find two numbers whose sum equals a specified value.

function equalToSum(array, target) {
  let left = 0, // শুরু পয়েন্টার
    right = array.length - 1; // শেষ পয়েন্টার
  while (left < right) {
    let sum = array[left] + array[right];
    if (sum === target) {
      return `[${left}, ${right}] (${array[left]} + ${array[right]} = ${target})`;
    } else if (sum < target) {
      left++; // যোগফল ছোট হলে বাম পয়েন্টার ডান দিকে সরান
    } else {
      right--; // যোগফল বড় হলে ডান পয়েন্টার বাম দিকে সরান
    }
  }
  return null; // যদি কোনো জোড়া সংখ্যা না পাওয়া যায়
}

const array = [1, 2, 3, 4];
console.log(equalToSum(array, 5));

// ---------------------------------------------------------------------------

// কোড ব্যাখ্যা:
// 1. Two-Pointer টেকনিক:
//    - অ্যারের প্রথম থেকে একটি পয়েন্টার (left) এবং শেষ থেকে আরেকটি পয়েন্টার (right) সেট করা হয়।
//    - প্রতিটি ধাপে:
//      - sum নামে একটি ভেরিয়েবল ব্যবহার করে দুটি সংখ্যার যোগফল বের করা হয়।
//      - যদি sum টার্গেটের সমান হয়, তখন ইন্ডেক্স এবং সংখ্যা সহ একটি স্ট্রিং রিটার্ন করা হয়।
//      - যদি sum ছোট হয়, তাহলে left পয়েন্টার ডান দিকে সরিয়ে যোগফল বাড়ানোর চেষ্টা করা হয়।
//      - যদি sum বড় হয়, তাহলে right পয়েন্টার বাম দিকে সরিয়ে যোগফল কমানোর চেষ্টা করা হয়।

// 2. যদি টার্গেট মানে পৌঁছানো না যায়:
//    - লুপ শেষ হলে null রিটার্ন করা হয়।

// 3. রিটার্ন স্টেটমেন্টে পরিবর্তন:
//    - ইন্ডেক্স এবং সংখ্যাগুলোর মান স্ট্রিং আকারে রিটার্ন করা হয়েছে।
// return `[${left}, ${right}] (${array[left]} + ${array[right]} = ${target})`;

// ---------------------------------------------------------------------------

// Edge Cases:
// Case 1: খালি অ্যারে
// console.log(equalToSum([], 10));
// আউটপুট: null

// Case 2: একটিমাত্র উপাদান
// console.log(equalToSum([5], 5));
// আউটপুট: null

// Case 3: একাধিক সমাধান
// - প্রথম যে জোড়াটি পাওয়া যায় সেটিই রিটার্ন হবে।
// console.log(equalToSum([1, 2, 4, 6, 6, 8], 12));
// আউটপুট: [2, 5] (4 + 8 = 12)

// Case 4: নেগেটিভ সংখ্যা
// console.log(equalToSum([-4, -1, 0, 2, 4, 5], 1));
// আউটপুট: [0, 5] (-4 + 5 = 1)

// ---------------------------------------------------------------------------

// Time Complexity:
// - প্রতিটি উপাদান লুপের মাধ্যমে সর্বোচ্চ একবার প্রক্রিয়াকরণ হয়।
// - O(n)।

// ---------------------------------------------------------------------------

// Space Complexity:
// - অতিরিক্ত কোনো ডেটা স্ট্রাকচার ব্যবহার করা হয়নি।
// - O(1)।
