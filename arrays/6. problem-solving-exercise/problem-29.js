// Given an array and a window size k, find the maximum sum within any consecutive k-sized elements.

function maxSumInWindow(arr, k) {
  if (arr.length < k) {
    throw new Error(
      "Array length must be greater than or equal to window size k."
    );
  }
  let i = 0, // উইন্ডোর শুরুর ইন্ডেক্স
    j = 0, // উইন্ডোর শেষ ইন্ডেক্স
    sum = 0, // বর্তমান উইন্ডোর যোগফল
    maxSum = -Infinity; // সর্বোচ্চ যোগফল (নেগেটিভ ইনফিনিটি দিয়ে শুরু)
  while (j < arr.length) {
    sum += arr[j]; // বর্তমান উইন্ডোতে নতুন উপাদান যোগ করা

    // যদি উইন্ডোর সাইজ \( k \)-এর চেয়ে ছোট থাকে
    if (j - i + 1 < k) {
      j++; // শুধুমাত্র উইন্ডো বাড়াও
    }

    // যদি উইন্ডোর সাইজ \( k \)-এর সমান হয়
    else if (j - i + 1 === k) {
      maxSum = Math.max(maxSum, sum); // সর্বোচ্চ যোগফল আপডেট করো
      sum -= arr[i]; // উইন্ডোর প্রথম উপাদান বাদ দাও
      i++; // উইন্ডোর শুরু সরাও
      j++; // উইন্ডোর শেষ সরাও
    }
  }
  return maxSum;
}

const array = [1, 2, 3, 4, 5, 6];
console.log(maxSumInWindow(array, 3));

// ---------------------------------------------------------------------------

// ব্যাখ্যা:
// Sliding Window Logic:
// 1. উইন্ডো ইনিশিয়ালাইজ:
//    - i=0,j=0।
//    - windowSize=j−i+1 দিয়ে উইন্ডোর সাইজ নির্ধারণ করা।
// 2. উইন্ডো বৃদ্ধি:
//    - sum+=arr[j]: নতুন উপাদান উইন্ডোতে যোগ করা।
//    - যদি windowSize<k, তাহলে j++ করে উইন্ডো বাড়াও।
// 3. উইন্ডো ফিক্সড সাইজ হলে:
//    - maxSum আপডেট করো: maxSum=Math.max(maxSum,sum)।
//    - sum-এ থেকে উইন্ডোর প্রথম উপাদান বাদ দাও: sum−=arr[i]।
//    - i++: উইন্ডোর শুরু সরাও।
//    - j++: উইন্ডোর শেষ সরাও।
// 4. শেষে maxSum রিটার্ন করো।

// ---------------------------------------------------------------------------

// উদাহরণ ব্যাখ্যা:
// arr=[1,2,3,4,5,6],k=3

// i	 j	  উইন্ডো      sum	  maxSum
// 0	 0	  [1]	        1	   -Infinity
// 0	 1	  [1, 2]	    3	   -Infinity
// 0	 2	  [1, 2, 3]	  6	    6
// 1	 3	  [2, 3, 4]	  9	    9
// 2	 4	  [3, 4, 5]	  12	  12
// 3	 5	  [4, 5, 6]	  15	  15

// Output: 15

// ---------------------------------------------------------------------------

// Time Complexity:
// - O(n): প্রতিটি উপাদান একবারই অ্যাক্সেস করা হয়।

// ---------------------------------------------------------------------------

// Space Complexity:
// - O(1): অতিরিক্ত কোনো ডেটা স্ট্রাকচার ব্যবহার হয় না।
