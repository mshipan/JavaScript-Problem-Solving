// Given an array, find all windows with at least k unique elements.

function findWindowsWithKUnique(arr, k) {
  let i = 0;
  let j = 0;
  const map = new Map();
  const result = [];

  while (j < arr.length) {
    // উইন্ডোতে নতুন উপাদান যোগ করা
    const element = arr[j];
    map.set(element, (map.get(element) || 0) + 1);

    // যখন উইন্ডোতে অন্তত k টি ইউনিক উপাদান থাকে
    while (map.size >= k) {
      result.push([i, j]); // উইন্ডোর সূচক যোগ করা

      // উইন্ডোর বাম দিক সরানো
      const leftElement = arr[i];
      map.set(leftElement, map.get(leftElement) - 1);
      if (map.get(leftElement) === 0) {
        map.delete(leftElement);
      }
      i++;
    }
    j++;
  }

  return result;
}

console.log(findWindowsWithKUnique([1, 2, 1, 3, 4, 2, 3], 3));
// আউটপুট: [[0, 3], [1, 4], [2, 5], [3, 6]]

console.log(findWindowsWithKUnique([1, 2, 3, 4, 5], 4));
// আউটপুট: [[0, 3], [1, 4]]

// ---------------------------------------------------------------------------

// ধাপ-ধাপে ব্যাখ্যা:
// - ইনপুট ও আউটপুট:
//   - ইনপুট: একটি অ্যারে এবং একটি সংখ্যা k।
//   - আউটপুট: এমন সকল উইন্ডোর সূচকসমূহ যেগুলোর মধ্যে অন্তত k টি ইউনিক উপাদান আছে।

// - ধারণা:
//   - স্লাইডিং উইন্ডো পদ্ধতি ব্যবহার করে উইন্ডোর ভিতরের উপাদান ট্র্যাক করব।
//   - একটি ম্যাপ ব্যবহার করে প্রতিটি উপাদানের ফ্রিকোয়েন্সি গণনা করব।
//   - যখনই উইন্ডোতে অন্তত k টি ইউনিক উপাদান থাকবে, সেই উইন্ডোটি সঞ্চয় করব।

// - অ্যালগরিদম:
//   - i=0 এবং j=0-তে শুরু করব।
//   - প্রতিটি j-তে উপাদান ম্যাপে যোগ করব এবং ফ্রিকোয়েন্সি আপডেট করব।
//   - যদি ম্যাপের সাইজ k-এর সমান বা বেশি হয়, সেই উইন্ডোর সূচক রেজাল্টে যোগ করব।
//   - i-কে এগিয়ে নিয়ে গিয়ে উইন্ডো সংকুচিত করব এবং ফ্রিকোয়েন্সি আপডেট করব।

// ---------------------------------------------------------------------------

// ধাপগুলো বিশ্লেষণ:
// - উইন্ডো প্রসারিত করা:
//   - j-এর সাহায্যে উইন্ডো প্রসারিত করব।
//   - প্রতিটি উপাদান ম্যাপে যোগ করব।

// - শর্ত চেক করা:
//   - যদি ম্যাপের সাইজ k-এর সমান বা বেশি হয়, বর্তমান উইন্ডোর সূচক সংরক্ষণ করব।

// - উইন্ডো সংকুচিত করা:
//   - i-কে ইনক্রিমেন্ট করব এবং বাম দিকের উপাদান ম্যাপ থেকে সরাব।

// ---------------------------------------------------------------------------

// সময় জটিলতা:
// - O(n), কারণ প্রতিটি উপাদান ম্যাপে একবার যোগ এবং একবার সরানো হয়।

// ---------------------------------------------------------------------------

// স্থান জটিলতা:
// - O(k), কারণ ম্যাপ সর্বোচ্চ k ইউনিক উপাদান ধারণ করবে।
