// অ্যাবস্ট্রাকশন (Abstraction) হলো Object-Oriented Programming (OOP) এর একটি গুরুত্বপূর্ণ ধারণা, যা সফটওয়্যার ডিজাইন এবং ডেভেলপমেন্টে জটিলতাকে সহজতর করে।
// অ্যাবস্ট্রাকশনের মাধ্যমে একটি সিস্টেমের জটিলতা লুকিয়ে ফেলে শুধু প্রয়োজনীয় এবং প্রাসঙ্গিক অংশগুলো প্রদর্শন করা হয়। এতে ব্যবহৃত উপাদানগুলোকে একটি নির্দিষ্ট স্তরে উপস্থাপন
// করা হয়, যেখানে ব্যবহারকারী শুধুমাত্র সেই স্তরের কার্যক্রমের সঙ্গে সম্পৃক্ত থাকে।

// **** অ্যাবস্ট্রাকশনের মূল ধারণা: ****
// 1. জটিলতা হ্রাস: অ্যাবস্ট্রাকশন এমন একটি প্রক্রিয়া যেখানে একটি অবজেক্ট বা সিস্টেমের সব কিছু দেখানোর পরিবর্তে, শুধুমাত্র সবচেয়ে গুরুত্বপূর্ণ এবং প্রয়োজনীয় দিকগুলোকে তুলে ধরা হয়।
//    এর মাধ্যমে ব্যবহারকারীকে জটিলতা থেকে রক্ষা করা হয়।

// 2. ইন্টারফেস প্রদর্শন: অ্যাবস্ট্রাকশন ব্যবহারে ব্যবহারকারী কেবলমাত্র অবজেক্টের কাজ কী তা জানে, কিন্তু কিভাবে তা বাস্তবায়িত হয় সে সম্পর্কে অবগত থাকে না। অর্থাৎ, একটি অবজেক্টের ইন্টারফেস
//    প্রকাশ করা হয়, কিন্তু ইমপ্লিমেন্টেশন লুকানো থাকে।

// 3. বাস্তবায়নের স্বাধীনতা: অ্যাবস্ট্রাকশনের মাধ্যমে একটি ক্লাস বা অবজেক্টের ইমপ্লিমেন্টেশন পরিবর্তন করা যায়, কিন্তু বাইরের ইন্টারফেস ঠিক থাকে। এর ফলে, প্রোগ্রামের স্থিতিশীলতা বজায় থাকে এবং
//    রক্ষণাবেক্ষণ সহজ হয়।

// উদাহরণস্বরূপ:
// ধরা যাক আমরা একটি ব্যাংক অ্যাকাউন্টের একটি সিস্টেম তৈরি করছি। এখানে অ্যাবস্ট্রাকশনের মাধ্যমে ব্যবহারকারীকে ব্যাংক অ্যাকাউন্টের নির্দিষ্ট কিছু কার্যক্রমের সুবিধা দেওয়া হবে,
// যেমন ব্যালেন্স চেক করা এবং টাকা তোলা। তবে, এই কার্যক্রমগুলোর পিছনের জটিলতা যেমন ডেটাবেস আপডেট, সিকিউরিটি চেক ইত্যাদি লুকিয়ে রাখা হবে।

class BankAccount {
  constructor(accountNumber, balance) {
    this.accountNumber = accountNumber;
    this.balance = balance;
  }

  // ব্যালেন্স চেক করার মেথড (অ্যাবস্ট্রাকশন)
  checkBalance() {
    return `Your balance is $${this.balance}`;
  }

  // টাকা তোলার মেথড (অ্যাবস্ট্রাকশন)
  withdraw(amount) {
    if (amount > this.balance) {
      return "Insufficient balance!";
    } else {
      this.balance -= amount;
      return `Withdrawal successful! Your new balance is $${this.balance}`;
    }
  }
}

// অ্যাকাউন্ট তৈরি করা
const myAccount = new BankAccount(123456789, 1000);

console.log(myAccount.checkBalance()); // Output: Your balance is $1000
console.log(myAccount.withdraw(200)); // Output: Withdrawal successful! Your new balance is $800
console.log(myAccount.checkBalance()); // Output: Your balance is $800

// উদাহরণ বিশ্লেষণ:

// 1. ব্যবহারকারী কী জানছে: ব্যবহারকারী checkBalance() এবং withdraw() মেথড দুটি সম্পর্কে জানে এবং এই মেথডগুলোর মাধ্যমে তার অ্যাকাউন্টের ব্যালেন্স চেক করতে এবং টাকা তুলতে পারে।
// 2. ব্যবহারকারী কী জানছে না: ব্যবহারকারী জানে না কিভাবে এই মেথডগুলো ইমপ্লিমেন্ট করা হয়েছে, যেমন: টাকা তোলার সময় ডেটাবেসে কীভাবে আপডেট করা হচ্ছে, নিরাপত্তা কীভাবে নিশ্চিত করা হচ্ছে ইত্যাদি।
// 3. অ্যাবস্ট্রাকশনের সুবিধা: অ্যাবস্ট্রাকশন ব্যবহারে ব্যাঙ্ক অ্যাকাউন্টের ব্যবহারকারীদের জন্য জটিলতা লুকানো হয়েছে এবং কেবলমাত্র তাদের প্রয়োজনীয় তথ্য এবং কার্যক্রম সরবরাহ করা হয়েছে।
//    এর ফলে ব্যবহারকারীরা সহজে এবং নিরাপদে সিস্টেমটি ব্যবহার করতে পারে।

// অ্যাবস্ট্রাকশনের উপকারিতা:

// 1. জটিলতার সরলীকরণ: সিস্টেমের অভ্যন্তরীণ জটিলতা ব্যবহারকারীদের কাছ থেকে লুকিয়ে রাখা হয়, যা ব্যবহারে সরলতা নিয়ে আসে।
// 2. কোডের রক্ষণাবেক্ষণ সহজ: অ্যাবস্ট্রাকশন ব্যবহারের মাধ্যমে অভ্যন্তরীণ কোড পরিবর্তন করা সহজ হয়, কারণ বাইরের ইন্টারফেস অপরিবর্তিত থাকে।
// 3. নিরাপত্তা বৃদ্ধি: অ্যাবস্ট্রাকশন ব্যবহার করে সংবেদনশীল ডেটা এবং লজিক ব্যবহারকারীর কাছ থেকে লুকিয়ে রাখা যায়, যা নিরাপত্তা বৃদ্ধি করে।
// 4. কোডের পুনঃব্যবহারযোগ্যতা: অ্যাবস্ট্রাকশন ব্যবহারে একটি সাধারণ ইন্টারফেস তৈরি করা যায়, যা ভিন্ন ভিন্ন প্রয়োজনে পুনঃব্যবহারযোগ্য হয়।

// **** About "interface" and "abstract" class ****
// Interface এবং Abstract Class এর ধারণাগুলো অ্যাবস্ট্রাকশনের সাথে সম্পর্কিত হলেও এগুলো JavaScript-এ সরাসরি উপস্থিত নয়, যেমনটি অন্যান্য OOP ভাষা (যেমন: Java, C#) তে পাওয়া যায়।
// তবে, JavaScript-এ আমরা এই ধারণাগুলিকে ভিন্নভাবে বাস্তবায়ন করতে পারি।

// Interface:
// Interface হলো এমন একটি কাঠামো যা শুধুমাত্র মেথডগুলোর নাম এবং সিগনেচার সংজ্ঞায়িত করে, কিন্তু তাদের ইমপ্লিমেন্টেশন দেয় না।
// Interface-এর মাধ্যমে নির্দিষ্ট কিছু মেথডের সেট তৈরি করা হয়, যা একটি ক্লাসকে অনুসরণ করতে হয়।
// JavaScript-এ সরাসরি Interface নেই, তবে ES6-এর ক্লাস এবং মেথডগুলির মাধ্যমে আমরা একটি "পৌরাণিক" Interface তৈরি করতে পারি। উদাহরণস্বরূপ,
// যদি কোনো ক্লাস নির্দিষ্ট মেথডগুলিকে অবশ্যই অন্তর্ভুক্ত করতে হয়, তাহলে আমরা Interface-এর মতো আচরণ করতে পারি।

// Abstract Class:
// Abstract Class একটি ক্লাস যা সম্পূর্ণ হতে পারে না। অর্থাৎ, এটি সরাসরি ইনস্ট্যান্স তৈরি করতে পারে না, তবে এটি অন্যান্য ক্লাসের জন্য একটি বেস হিসেবে কাজ করে।
// Abstract Class সাধারণত এক বা একাধিক Abstract মেথড ধারণ করে, যেগুলো Child ক্লাসে বাস্তবায়ন করতে হয়।
// JavaScript-এ সরাসরি Abstract Class নেই, তবে আমরা Parent ক্লাস তৈরি করে এবং একটি কনভেনশন অনুসরণ করে এটি বাস্তবায়ন করতে পারি।

// উদাহরণ: Interface এবং Abstract Class কনসেপ্ট JavaScript-এ

// Abstract Class
class Shape {
  constructor(name) {
    if (this.constructor === Shape) {
      throw new Error("Abstract classes can't be instantiated.");
    }
    this.name = name;
  }

  // Abstract Method (যেটি Child ক্লাসে বাস্তবায়ন করতে হবে)
  calculateArea() {
    throw new Error("Method 'calculateArea()' must be implemented.");
  }
}

// Concrete Class (Shape ক্লাস থেকে Inherit করে)
class Rectangle extends Shape {
  constructor(width, height) {
    super("Rectangle");
    this.width = width;
    this.height = height;
  }

  // Abstract Method এর বাস্তবায়ন
  calculateArea() {
    return this.width * this.height;
  }
}

// Interface এর মতো আচরণ (কনভেনশনাল, JavaScript-এ সরাসরি নয়)
class Circle extends Shape {
  constructor(radius) {
    super("Circle");
    this.radius = radius;
  }

  // Interface এর মেথড বাস্তবায়ন
  calculateArea() {
    return Math.PI * Math.pow(this.radius, 2);
  }
}

// ইনস্ট্যান্স তৈরি করে Area ক্যালকুলেশন
const myRectangle = new Rectangle(10, 5);
console.log(`${myRectangle.name} এর এলাকা: ${myRectangle.calculateArea()}`);

const myCircle = new Circle(7);
console.log(`${myCircle.name} এর এলাকা: ${myCircle.calculateArea()}`);

// এখানে Shape এর ইনস্ট্যান্স তৈরি করতে গেলে এরর হবে
// const shape = new Shape(); // Error: Abstract classes can't be instantiated.

// ব্যাখ্যা:
// 1. Shape ক্লাস: এটি একটি Abstract Class হিসাবে কাজ করছে, যা সরাসরি ইনস্ট্যান্স তৈরি করতে পারবে না। এটি calculateArea() নামে একটি Abstract Method ধারণ করছে,
//    যা Child ক্লাসগুলোকে অবশ্যই বাস্তবায়ন করতে হবে।

// 2. Rectangle এবং Circle ক্লাস: এই ক্লাসগুলো Shape ক্লাস থেকে Inherit করেছে এবং calculateArea() মেথডের বাস্তবায়ন দিয়েছে।

// 3. কনভেনশনাল Interface: যদিও JavaScript-এ সরাসরি Interface নেই, তবে নির্দিষ্ট মেথডগুলিকে একটি নির্দিষ্ট সিগনেচারের সাথে বাস্তবায়নের জন্য এমন কাঠামো তৈরি করা হয়েছে।
