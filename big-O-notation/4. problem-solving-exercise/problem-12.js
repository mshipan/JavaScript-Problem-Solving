// Write a function that takes an array of numbers and returns an array with all
// the elements doubled. Analyze both the time and space complexity of your function.

function doubledArray(arr) {
  let doubledNum = [];
  for (let i = 0; i < arr.length; i++) {
    doubledNum.push((arr[i] *= 2));
  }
  return doubledNum;
}

const arry = [1, 2, 3, 4, 5];
console.log(doubledArray(arry));

// --------------------------------------------------------------------------

// টাইম কমপ্লেক্সিটি:
// এই ফাংশনের টাইম কমপ্লেক্সিটি বিশ্লেষণ করা যাক:
// 1. for লুপটি অ্যারেটির প্রতিটি উপাদান দিয়ে একবার করে চলে, তাই লুপের ইটারেশন সংখ্যা হবে n,
//    যেখানে n হচ্ছে অ্যারেটির দৈর্ঘ্য।
// 2. প্রতিটি ইটারেশনে আমরা প্রতিটি উপাদানকে দ্বিগুণ করে নতুন অ্যারেতে পুশ করছি।

// এখন, যেহেতু লুপটি অ্যারেটির প্রতিটি উপাদান নিয়ে একবার করে কাজ করছে, তাই এই ফাংশনের টাইম
// কমপ্লেক্সিটি হবে O(n), যেখানে n হচ্ছে অ্যারেটির দৈর্ঘ্য।

// স্পেস কমপ্লেক্সিটি:
// স্পেস কমপ্লেক্সিটি হচ্ছে কতটা অতিরিক্ত মেমোরি ব্যবহার হচ্ছে ফাংশনের চলাকালীন সময়ে।
// 1. এখানে doubledNum নামের একটি নতুন অ্যারে তৈরি করা হচ্ছে যা অ্যারেটির প্রতিটি উপাদানকে
//    দ্বিগুণ করে রাখছে।
// 2. এই নতুন অ্যারেটির আকার হবে মূল অ্যারেটির সমান, কারণ প্রতিটি উপাদান দ্বিগুণ করার পরেও
//    উপাদান সংখ্যা পরিবর্তিত হচ্ছে না।

// তাহলে স্পেস কমপ্লেক্সিটিও হবে O(n), কারণ অ্যারের প্রতিটি উপাদানের জন্য নতুন জায়গা প্রয়োজন হচ্ছে।

// সংক্ষেপে ব্যাখ্যা:
// - টাইম কমপ্লেক্সিটি O(n) কারণ লুপটি প্রতিটি উপাদানকে একবার করে প্রসেস করছে।
// - স্পেস কমপ্লেক্সিটি O(n) কারণ আমরা নতুন একটি অ্যারে তৈরি করছি যা মূল অ্যারেটির প্রতিটি উপাদানের
//   দ্বিগুণ মান ধারণ করছে।

// এটা একটি কার্যকরী ফাংশন যেখানে আমরা একইসাথে টাইম এবং স্পেস উভয় কমপ্লেক্সিটি O(n) রাখতে
// পেরেছি।
