// Write a function to reverse an array of integers. Try to optimize it for both
// time and space complexity.

function reverseArray(arr) {
  let left = 0, // অ্যারের শুরু পজিশন
    right = arr.length - 1; // অ্যারের শেষ পজিশন

  // প্রথম এবং শেষ ইন্ডেক্স থেকে একে অপরের দিকে এগিয়ে যাওয়া
  while (left < right) {
    // দুই প্রান্তের উপাদান অদল-বদল করা (swap)
    [arr[left], arr[right]] = [arr[right], arr[left]];
    left++; // বাম পজিশনকে এক ধাপ ডানে সরানো
    right--; // ডান পজিশনকে এক ধাপ বামে সরানো
  }
  return arr; // উল্টানো অ্যারে রিটার্ন করা
}

const array = [1, 2, 3, 4, 5, 6];
console.log(reverseArray(array));

// ---------------------------------------------------------------------

// কোডের ব্যাখ্যা:
// 1. আমরা প্রথমে left এবং right নামে দুইটি ভেরিয়েবল সেট করি, যা অ্যারের শুরু এবং শেষ উপাদান
//    নির্দেশ করবে।
// 2. left ইন্ডেক্স থেকে শুরু করে right ইন্ডেক্স পর্যন্ত প্রতিটি ধাপে দুই প্রান্তের উপাদান অদল-বদল করি।
// 3. প্রতিবার left ইন্ডেক্সকে এক ধাপ ডানে এবং right ইন্ডেক্সকে এক ধাপ বামে সরাই।
// 4. এই প্রক্রিয়া চলবে যতক্ষণ না left ইন্ডেক্স right ইন্ডেক্সের সমান বা বড় হয়ে যায়।

// সময় জটিলতা (Time Complexity):
// - আমরা প্রতিটি ইন্ডেক্সে একবার করে অ্যাক্সেস করছি এবং শুধুমাত্র একবার অদল-বদল করছি। তাই এই
//   ফাংশনের সময় জটিলতা হবে O(n), যেখানে n হল অ্যারের উপাদান সংখ্যা।

// স্থান জটিলতা (Space Complexity):
// - কোনো নতুন অ্যারে তৈরি না করে ইনপুট অ্যারেতেই অদল-বদল করা হচ্ছে। তাই অতিরিক্ত স্থান ব্যবহার
//   হচ্ছে না।
// - স্থান জটিলতা হবে O(1), কারণ কেবলমাত্র কিছু অতিরিক্ত ভেরিয়েবল ব্যবহার করছি (যেমন left এবং
//   right)।

// সারসংক্ষেপ:
// এই ফাংশনটি উল্টানোর জন্য সময় এবং স্থান উভয় ক্ষেত্রেই অপ্টিমাইজড। সময় জটিলতা O(n) এবং
// স্থান জটিলতা O(1)।
