// Write a function that finds all the duplicate elements in an array by comparing
// each element with every other element. What is the time complexity of your function?

function findDuplicates(arr) {
  let duplicates = [];
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j] && !duplicates.includes(arr[i])) {
        duplicates.push(arr[i]);
      }
    }
  }
  return duplicates;
}

const array = [1, 2, 3, 4, 5, 3, 2, 6, 4];
console.log(findDuplicates(array)); // Output: [2, 3, 4]

// --------------------------------------------------------------------

// ব্যাখ্যা:
// - এই ফাংশনে আমরা একটি অ্যারে arr থেকে ডুপ্লিকেট উপাদানগুলো খুঁজে বের করছি।
// - প্রথম লুপে i ইন্ডেক্সের প্রতিটি উপাদানকে অন্য লুপে j ইন্ডেক্সের উপাদানগুলোর সাথে তুলনা করা হচ্ছে।
// - যদি arr[i] === arr[j] হয় এবং সেই উপাদানটি duplicates অ্যারেতে না থাকে, তবে সেটি
//   duplicates অ্যারেতে পুশ করা হচ্ছে।

// টাইম কমপ্লেক্সিটি:

// এখানে টাইম কমপ্লেক্সিটি বিশ্লেষণ করা যাক:

// - প্রথম লুপ i অ্যারেটির প্রতিটি উপাদান দিয়ে চলবে এবং এর জন্য n সংখ্যক ইটারেশন হবে, যেখানে n
//   হচ্ছে অ্যারেটির দৈর্ঘ্য।
// - দ্বিতীয় লুপ j প্রতি ইটারেশনে n-i-1 সংখ্যক ইটারেশন করে চলবে, কারণ এটি i এর পরে থাকা
//   উপাদানগুলো নিয়ে কাজ করে।

// ফলে প্রতিটি উপাদানের জন্য বাকি সব উপাদানগুলোর সাথে তুলনা করা হচ্ছে। তাই, এই ফাংশনের টাইম
// কমপ্লেক্সিটি হবে O(n^2)।

// বিস্তারিত ব্যাখ্যা:
// - প্রথম লুপটি n বার চলে এবং দ্বিতীয় লুপটি প্রতিবারই প্রথম লুপের চলার উপর নির্ভর করে কাজ করে।
// - প্রতিটি উপাদানকে বাকি সব উপাদানের সাথে তুলনা করতে গিয়ে লুপের সংখ্যা বাড়তে থাকে।
// - একারণে, টাইম কমপ্লেক্সিটি O(n^2) হয়, কারণ প্রতিটি উপাদানকে অন্য উপাদানগুলোর সাথে তুলনা
//   করার জন্য দুটো নেস্টেড লুপ ব্যবহার করা হচ্ছে।

// এই ফাংশনটি ছোট অ্যারের জন্য কাজ করতে ভালো হলেও বড় অ্যারে থাকলে এর কার্যক্ষমতা কমে
// যাবে কারণ এটি প্রতিটি উপাদানের সাথে প্রতিটি উপাদানকে তুলনা করছে।
