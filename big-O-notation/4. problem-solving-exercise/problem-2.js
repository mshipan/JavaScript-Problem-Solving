// Write a function that creates a new array by duplicating the elements of an input
// array. Analyze the space complexity of your function.

function duplicateArray(arr) {
  let newArr = []; // নতুন একটি খালি অ্যারে তৈরি করা হলো

  for (let i = 0; i < arr.length; i++) {
    newArr.push(arr[i]); // ইনপুট অ্যারের প্রতিটি উপাদান নতুন অ্যারেতে যুক্ত করা হচ্ছে
  }

  return newArr; // নতুন অ্যারে রিটার্ন করা হচ্ছে
}

const nArr = [1, 2, 3, 4, 5];
console.log(duplicateArray(nArr));

// -------------------------------------------------------------------------

// স্পেস কমপ্লেক্সিটি বিশ্লেষণ:
// স্পেস কমপ্লেক্সিটি ফাংশনের মধ্যে কতটুকু অতিরিক্ত মেমোরি ব্যবহার হচ্ছে, তা মাপার প্রক্রিয়া।
// আমরা শুধু অতিরিক্ত মেমোরি হিসেব করব, ইনপুট হিসেবে দেওয়া ডেটা নয়।

// 1. ইনপুট অ্যারে (arr):
//    - ইনপুট অ্যারে arr ফাংশনের ভিতরে ব্যবহার করা হলেও, এটি স্পেস কমপ্লেক্সিটিতে গণনা করা হয় না,
//      কারণ এটি মূল ইনপুট এবং নতুন কিছু নয়।

// 2. নতুন অ্যারে (newArr):
//    - ফাংশনটি নতুন একটি অ্যারে তৈরি করছে, যেখানে ইনপুট অ্যারের সব উপাদান কপি করা হচ্ছে।
//    - যদি ইনপুট অ্যারেতে nটি উপাদান থাকে, তাহলে নতুন অ্যারেটির ক্ষেত্রেও nটি উপাদান থাকবে।
//    - অতএব, এই নতুন অ্যারেটির জন্য O(n) স্পেস লাগবে, যেখানে n হলো ইনপুট অ্যারের দৈর্ঘ্য।

// 3. অস্থায়ী ভেরিয়েবল:
//    - i ভেরিয়েবলটি লুপে ব্যবহৃত হচ্ছে, যা একটি সংখ্যা এবং এটি নির্দিষ্ট মেমোরি ব্যবহার করে,
//      অর্থাৎ এর স্পেস কমপ্লেক্সিটি O(1)।

// মোট স্পেস কমপ্লেক্সিটি:
// - ফাংশনের স্পেস কমপ্লেক্সিটি প্রধানত নতুন অ্যারেটির উপর নির্ভর করে, যেটি ইনপুট অ্যারের আকার
//   অনুযায়ী বাড়ে।
// - অতএব, এই ফাংশনের স্পেস কমপ্লেক্সিটি হলো O(n), যেখানে n হলো ইনপুট অ্যারের উপাদান সংখ্যা।

// উদাহরণ:
// যদি ইনপুট অ্যারে [1, 2, 3, 4, 5] হয়, তাহলে নতুন অ্যারেও একই আকারের হবে [1, 2, 3, 4, 5]।
// কারণ নতুন অ্যারেটি ইনপুট অ্যারের প্রতিটি উপাদান কপি করছে, স্পেস কমপ্লেক্সিটি হবে O(n)।
