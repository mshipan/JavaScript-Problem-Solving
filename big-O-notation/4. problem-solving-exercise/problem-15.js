// Write a function that prints all possible subsets of a given set. What is the time
// complexity of generating all subsets?

function generateSubsets(set) {
  const subsets = [];
  const n = set.length;

  // Loop through each binary representation from 0 to 2^n - 1
  for (let i = 0; i < 1 << n; i++) {
    const subset = [];
    for (let j = 0; j < n; j++) {
      // Check if the j-th element is included in the i-th subset
      if (i & (1 << j)) {
        subset.push(set[j]);
      }
    }
    subsets.push(subset);
  }
  return subsets;
}

const set = [1, 2, 3];
console.log(generateSubsets(set));

// ----------------------------------------------------------------

// ব্যাখ্যা:
// উপরের ফাংশনটি একটি সেটের সমস্ত সাবসেট তৈরি করে। একটি সেটের মোট 2^n সংখ্যক সাবসেট থাকে,
// যেখানে n হলো সেটের উপাদান সংখ্যা।

// Subsets কিভাবে কাজ করে:
// - আমরা প্রত্যেকটি সাবসেটকে একটি বাইনারি সংখ্যা হিসাবে উপস্থাপন করতে পারি।
// - উদাহরণস্বরূপ, যদি সেটে 3টি উপাদান থাকে, তাহলে 3টি উপাদানকে অন্তর্ভুক্ত বা বাদ দেওয়ার
//   2^3 = 8টি উপায় রয়েছে।
// - বাইনারি রূপ ব্যবহার করে প্রতিটি সাবসেট তৈরি করা হয়, যেখানে 1 মানে উপাদানটি সাবসেটে রয়েছে
//   এবং 0 মানে তা নেই।

// টাইম কমপ্লেক্সিটি (Time Complexity):
// O(2^n * n)

// কারণ:
// - একটি সেটের n উপাদানের জন্য মোট 2^n সংখ্যক সাবসেট থাকবে, কারণ প্রতিটি উপাদান হয়
//   সাবসেটে থাকে বা থাকে না।
// - প্রতিটি সাবসেট তৈরি করার সময় আমাদের n উপাদানগুলো পরীক্ষা করতে হবে (যেমন উপাদানটি
//   সাবসেটে থাকবে কিনা তা নির্ধারণ করতে)।
// - তাই, 2^n সংখ্যক সাবসেট জেনারেট করতে n সংখ্যক উপাদান পরীক্ষা করতে হবে, যার ফলে টাইম
//   কমপ্লেক্সিটি হয় O(2^n * n)।

// উদাহরণ:
// যদি আপনার একটি 3 উপাদানের সেট থাকে [1, 2, 3], তাহলে সবমিলিয়ে 8টি (2^3) সাবসেট তৈরি হবে।
