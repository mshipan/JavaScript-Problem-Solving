// Write a function that returns the maximum element in an array. Analyze the time
// complexity of your function.

function findMax(arr) {
  if (arr.length === 0) {
    return null; // যদি অ্যারে খালি হয়, তাহলে null রিটার্ন করবে
  }

  let max = arr[0]; // প্রথম উপাদানকে সর্বাধিক (max) হিসাবে ধরছে

  for (let i = 1; i < arr.length; i++) {
    // অ্যারের বাকি উপাদানগুলোর সাথে তুলনা করা হচ্ছে
    if (arr[i] > max) {
      max = arr[i]; // যদি নতুন উপাদান বড় হয়, তাহলে max আপডেট হচ্ছে
    }
  }

  return max; // সর্বাধিক মান রিটার্ন করছে
}

const nums = [1, 2, 4, 5, 3, 9];
console.log(findMax(nums)); // আউটপুট: 9

// ----------------------------------------------------------------------------

// Time Complexity Analysis
// এখন, আমরা ধাপে ধাপে বুঝবো ফাংশনের সময় জটিলতা:

// 1. প্রথম ধাপ: খালি অ্যারে চেক করা (O(1))
//      if (arr.length === 0) { return null; }
// এখানে শুধুমাত্র একটি শর্ত (condition) পরীক্ষা করা হচ্ছে। এটি একবারে সম্পন্ন হয়,
// তাই এর সময় জটিলতা O(1)।

// 2. দ্বিতীয় ধাপ: সর্বাধিক মানের জন্য প্রাথমিক মান সেট করা (O(1))
//      let max = arr[0];
// এখানে প্রথম উপাদানকে max হিসেবে সেট করা হচ্ছে। এটি একটি ধাপে সম্পন্ন হয়,
// তাই এর সময় জটিলতা O(1)।

// 3. তৃতীয় ধাপ: লুপিং (O(n))
//      for (let i = 1; i < arr.length; i++) {
//          if (arr[i] > max) {
//          max = arr[i];
//          }
//      }

// এই অংশে আমরা লুপের মাধ্যমে অ্যারের প্রতিটি উপাদান যাচাই করছি।
// - arr.length যদি n হয়, তাহলে এই লুপটি মোট n-1 বার চলবে (প্রথম উপাদান আগে থেকেই
//   max হিসেবে সেট করা হয়েছে)।
// - প্রতিটি ইটারেশনে, একটি তুলনা করা হচ্ছে (O(1)) এবং যদি প্রয়োজন হয় তাহলে
//   max আপডেট করা হচ্ছে (O(1))।
// সুতরাং, পুরো লুপের সময় জটিলতা হবে O(n)।

// 4. ফলাফল রিটার্ন করা (O(1))
//      return max;
// শেষ ধাপে, শুধুমাত্র max রিটার্ন করা হচ্ছে, যা O(1) সময়ের মধ্যে সম্পন্ন হয়।

// সামগ্রিক সময় জটিলতা:
// লুপিং-এর সময় জটিলতা হলো O(n)।
// বাকি অংশগুলোর সময় জটিলতা হলো O(1)।

// যেহেতু লুপিং অংশটাই সবচেয়ে বেশি সময় নেয়, তাই পুরো ফাংশনের সময় জটিলতা দাঁড়ায় O(n)।

// উদাহরণ:
// ধরুন, আপনার একটি অ্যারে আছে [3, 1, 4, 1, 5, 9, 2, 6]। এখানে n = 8 (অ্যারের দৈর্ঘ্য),
// সুতরাং এই ফাংশনটি সর্বাধিক মান খুঁজতে অ্যারের প্রতিটি উপাদানকে একবার করে পরীক্ষা করবে এবং
// O(n) সময়ে কাজ শেষ করবে।
